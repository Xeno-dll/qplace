<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>q/place</title>
  <style>
    :root{
      --bg:#0f1115;--panel:#151823;--muted:#8b93a7;--text:#e8ecf3;--accent:#6aa3ff;--ok:#5ee380;--warn:#ffcc66;--danger:#ff7a7a;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0; background:var(--bg); color:var(--text); font:14px ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial,"Apple Color Emoji","Segoe UI Emoji"}
    .app{display:grid; grid-template-columns: 320px 1fr; grid-template-rows:auto 1fr; gap:12px; height:100%; padding:12px}
    header{grid-column:1/3; display:flex; align-items:center; justify-content:space-between; background:var(--panel); border:1px solid #23283a; border-radius:16px; padding:10px 12px}
    header h1{margin:0; font-size:16px; letter-spacing:.2px}
    header .right{display:flex; gap:8px; align-items:center}
    .btn{appearance:none; border:1px solid #2a314a; background:#1a2031; color:var(--text); padding:8px 10px; border-radius:12px; cursor:pointer}
    .btn:hover{border-color:#33406d}
    .btn:disabled{opacity:.6; cursor:not-allowed}
    .panel{background:var(--panel); border:1px solid #23283a; border-radius:16px; padding:12px}
    .tools{display:flex; flex-direction:column; gap:12px}
    .tools .row{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
    .palette{display:grid; grid-template-columns:repeat(10, 1fr); gap:6px}
    .swatch{width:26px; height:26px; border-radius:6px; border:1px solid #00000055; cursor:pointer}
    .swatch.active{outline:2px solid var(--accent)}
    .stat{color:var(--muted)}
    .canvas-wrap{position:relative; overflow:hidden; border-radius:16px}
    canvas{display:block; background:#fff; cursor:crosshair; touch-action:none}
    .hud{position:absolute; left:8px; bottom:8px; background:#0f1115cc; backdrop-filter: blur(6px); border:1px solid #23283a; padding:6px 8px; border-radius:10px; color:var(--muted)}
    .toast{position:fixed; right:14px; bottom:14px; background:#0f1115f2; border:1px solid #23283a; padding:10px 12px; border-radius:12px}
    .range{accent-color:var(--accent)}
    .grid-toggle{display:flex; align-items:center; gap:6px}
    code{background:#0b0d13; border:1px solid #23283a; padding:2px 6px; border-radius:6px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>q/place</h1>
      <div class="right">
        <button class="btn" id="exportPng">Export PNG</button>
        <button class="btn" id="exportJson">Export JSON</button>
        <button class="btn" id="importJson">Import JSON</button>
        <a class="btn" id="ghLink" href="#" target="_blank" rel="noreferrer">Source</a>
      </div>
    </header>

    <aside class="panel tools">
      <div class="row">
        <label>Canvas Size: <code id="sizeLabel">500×500</code></label>
      </div>
      <div class="row">
        <label>Zoom: <code id="zoomLabel">10×</code></label>
        <input id="zoomRange" class="range" type="range" min="2" max="60" step="1" value="10" />
        <button class="btn" id="zoomIn">＋</button>
        <button class="btn" id="zoomOut">－</button>
        <label class="grid-toggle"><input type="checkbox" id="gridToggle" checked /> Grid</label>
      </div>
      <div class="row">
        <span class="stat">Pos: <code id="posLabel">—</code></span>
      </div>
      <div>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:6px">
          <div>Palette</div>
          <div class="stat">Pick or press <code>V</code> to eyedrop</div>
        </div>
        <div class="palette" id="palette"></div>
      </div>
      <div class="row">
        <input type="color" id="customColor" value="#ff0000" />
        <button class="btn" id="addColor">Add</button>
        <button class="btn" id="clearCanvas">Clear</button>
      </div>
      <div class="row">
        <span class="stat">Cooldown: <code id="cooldown">ready</code></span>
      </div>
    </aside>

    <main class="panel canvas-wrap">
      <canvas id="canvas" width="1200" height="800"></canvas>
      <div class="hud" id="hud">Drag to pan • Wheel to zoom • Click to place</div>
    </main>
  </div>

  <script>
  // ==== Config (change these for your instance) =============================
  const PARAM_SIZE = new URL(location.href).searchParams.get('size');
  const CANVAS_SIZE = Math.max(1, Math.min(2000, Number(PARAM_SIZE)||500)); // default 500, easy to change
  const PLACE_COOLDOWN_MS = 5000; // 5 seconds
  const STORAGE_KEY = `rplace_v1_${CANVAS_SIZE}`;

  // ==== State ================================================================
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  let zoom = 10; // screen pixels per world pixel
  let showGrid = true;
  let viewX = -(canvas.width/2 - (CANVAS_SIZE*zoom)/2); // center view
  let viewY = -(canvas.height/2 - (CANVAS_SIZE*zoom)/2);
  let isPanning = false; let lastX=0, lastY=0;
  let eyedropper = false;

  // Pixel buffer: Uint32 RGBA (premult not needed). Default white.
  const pixels = new Uint32Array(CANVAS_SIZE * CANVAS_SIZE);
  const WHITE = 0xFFFFFFFF >>> 0;
  pixels.fill(WHITE);

  // Try load from localStorage
  (function load(){
    try{
      const b64 = localStorage.getItem(STORAGE_KEY);
      if(b64){
        const bin = atob(b64);
        const buf = new Uint8Array(bin.length);
        for(let i=0;i<bin.length;i++) buf[i]=bin.charCodeAt(i);
        const u32 = new Uint32Array(buf.buffer);
        if(u32.length === pixels.length) pixels.set(u32);
      }
    }catch(e){ console.warn('load failed', e); }
  })();

  function save(){
    try{
      const u8 = new Uint8Array(pixels.buffer);
      let s=''; for(let i=0;i<u8.length;i++) s += String.fromCharCode(u8[i]);
      localStorage.setItem(STORAGE_KEY, btoa(s));
    }catch(e){ console.warn('save failed', e); }
  }

  // ==== UI wiring ============================================================
  const sizeLabel = document.getElementById('sizeLabel');
  sizeLabel.textContent = `${CANVAS_SIZE}×${CANVAS_SIZE}`;
  const posLabel = document.getElementById('posLabel');
  const zoomLabel = document.getElementById('zoomLabel');
  const zoomRange = document.getElementById('zoomRange');
  const gridToggle = document.getElementById('gridToggle');
  const cooldownLabel = document.getElementById('cooldown');
  const hud = document.getElementById('hud');
  const ghLink = document.getElementById('ghLink');
  ghLink.href = 'https://github.com/';

  function updateZoomLabel(){ zoomLabel.textContent = `${zoom}×`; }
  updateZoomLabel();
  zoomRange.value = zoom;

  document.getElementById('zoomIn').onclick = ()=>{ setZoom(zoom+2); };
  document.getElementById('zoomOut').onclick = ()=>{ setZoom(zoom-2); };
  zoomRange.oninput = e=> setZoom(Number(e.target.value));
  gridToggle.onchange = e=> { showGrid = e.target.checked; };

  // Palette
  const defaultPalette = [
    '#000000','#666666','#999999','#ffffff',
    '#ff0000','#ff7f7f','#ffa500','#ffd27f',
    '#ffff00','#d7ff7f','#00ff00','#7fff7f',
    '#00ffff','#7fdfff','#0000ff','#7f7fff',
    '#ff00ff','#df7fff','#8b4513','#c79c6a'
  ];
  const paletteEl = document.getElementById('palette');
  const customColor = document.getElementById('customColor');
  const addColor = document.getElementById('addColor');
  let currentColor = 0xFF0000FF; // red (RGBA little-endian: 0xAABBGGRR for putImageData? We'll draw manually)

  // Convert CSS hex to Uint32 RGBA (little endian for ImageData)
  function hexToU32(hex){
    const v = parseInt(hex.slice(1),16);
    const r = (v>>16)&255, g=(v>>8)&255, b=v&255;
    return (255<<24) | (b<<16) | (g<<8) | (r);
  }
  function u32ToCss(u){
    const r=u&255, g=(u>>8)&255, b=(u>>16)&255;
    return `rgb(${r},${g},${b})`;
  }
  function setActiveSwatch(el){
    for(const c of paletteEl.children) c.classList.remove('active');
    el.classList.add('active');
  }
  function addSwatch(colorCss){
    const u = hexToU32(colorCss);
    const sw = document.createElement('button');
    sw.className='swatch';
    sw.style.background = colorCss;
    sw.title = colorCss;
    sw.onclick = ()=>{ currentColor = u; setActiveSwatch(sw); };
    paletteEl.appendChild(sw);
    return sw;
  }
  defaultPalette.forEach(c=> addSwatch(c));
  setActiveSwatch(paletteEl.children[4]); // select red

  addColor.onclick = ()=>{
    const sw = addSwatch(customColor.value);
    sw.click();
  };

  document.getElementById('clearCanvas').onclick = ()=>{
    if(confirm('Clear the canvas to white?')){ pixels.fill(WHITE); save(); }
  };

  // Export/Import
  document.getElementById('exportPng').onclick = ()=>{
    const tmp = document.createElement('canvas');
    tmp.width = CANVAS_SIZE; tmp.height = CANVAS_SIZE;
    const tctx = tmp.getContext('2d');
    const img = new ImageData(CANVAS_SIZE, CANVAS_SIZE);
    const u32 = new Uint32Array(img.data.buffer);
    u32.set(pixels);
    tctx.putImageData(img,0,0);
    const url = tmp.toDataURL('image/png');
    const a=document.createElement('a'); a.href=url; a.download=`rplace_${CANVAS_SIZE}.png`; a.click();
  };
  document.getElementById('exportJson').onclick = ()=>{
    const u8 = new Uint8Array(pixels.buffer);
    let s=''; for(let i=0;i<u8.length;i++) s += String.fromCharCode(u8[i]);
    const b64 = btoa(s);
    const blob = new Blob([b64],{type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=`rplace_${CANVAS_SIZE}.json`; a.click();
    setTimeout(()=>URL.revokeObjectURL(url), 5000);
  };
  document.getElementById('importJson').onclick = ()=>{
    const inp = document.createElement('input'); inp.type='file'; inp.accept='.json,.txt';
    inp.onchange = async ()=>{
      const file = inp.files[0]; if(!file) return;
      const text = await file.text();
      try{
        const bin = atob(text.trim());
        const buf = new Uint8Array(bin.length);
        for(let i=0;i<bin.length;i++) buf[i]=bin.charCodeAt(i);
        const u32 = new Uint32Array(buf.buffer);
        if(u32.length!==pixels.length) throw new Error('Size mismatch');
        pixels.set(u32); save();
      }catch(e){ alert('Import failed: '+e.message); }
    };
    inp.click();
  };

  // ==== Interaction ==========================================================
  function setZoom(z, around){
    const clamped = Math.max(2, Math.min(60, Math.round(z)));
    if(around){
      // keep cursor position stable in world coords
      const wx = (around.x - viewX)/zoom;
      const wy = (around.y - viewY)/zoom;
      viewX = around.x - wx*clamped;
      viewY = around.y - wy*clamped;
    }
    zoom = clamped; zoomRange.value = zoom; updateZoomLabel();
  }

  canvas.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const around = { x: e.clientX - rect.left, y: e.clientY - rect.top };
    const delta = Math.sign(e.deltaY);
    setZoom(zoom + (delta<0? 2 : -2), around);
  }, {passive:false});

  canvas.addEventListener('pointerdown', (e)=>{
    canvas.setPointerCapture(e.pointerId);
    if(e.button===1 || e.button===2 || e.shiftKey){ isPanning=true; lastX=e.clientX; lastY=e.clientY; return; }
    handleClick(e);
  });
  canvas.addEventListener('contextmenu', e=> e.preventDefault());

  canvas.addEventListener('pointermove', (e)=>{
    if(isPanning){
      const dx = e.clientX - lastX; const dy = e.clientY - lastY; lastX=e.clientX; lastY=e.clientY;
      viewX += dx; viewY += dy; return;
    }
    const pos = screenToWorld(e);
    if(pos) posLabel.textContent = `${pos.x},${pos.y}`; else posLabel.textContent='—';
  });

  window.addEventListener('pointerup', ()=>{ isPanning=false; });
  window.addEventListener('keydown', (e)=>{
    if(e.key==='v' || e.key==='V'){ eyedropper = true; hud.textContent='Eyedropper ON (click to pick). Press V again to toggle.'; }
    if(e.key==='Escape'){ eyedropper=false; hud.textContent='Drag to pan • Wheel to zoom • Click to place'; }
  });
  window.addEventListener('keyup', (e)=>{
    if(e.key==='v' || e.key==='V'){ eyedropper = false; hud.textContent='Drag to pan • Wheel to zoom • Click to place'; }
  });

  function screenToWorld(e){
    const rect = canvas.getBoundingClientRect();
    const sx = e.clientX - rect.left; const sy = e.clientY - rect.top;
    const wx = Math.floor((sx - viewX)/zoom);
    const wy = Math.floor((sy - viewY)/zoom);
    if(wx<0||wy<0||wx>=CANVAS_SIZE||wy>=CANVAS_SIZE) return null;
    return {x:wx, y:wy};
  }

  function u32At(x,y){ return pixels[y*CANVAS_SIZE + x]; }
  function setU32(x,y,val){ pixels[y*CANVAS_SIZE + x] = val >>> 0; }

  function handleClick(e){
    const now = Date.now();
    const last = Number(localStorage.getItem('rplace_last_place'))||0;
    const remain = last + PLACE_COOLDOWN_MS - now;
    const pos = screenToWorld(e);
    if(!pos) return;

    if(eyedropper){ currentColor = u32At(pos.x,pos.y); // pick
      // Set active swatch visual to none; no need to add if not exists
      hud.textContent = `Picked ${u32ToCss(currentColor)} — click to place or press Esc/V to exit`;
      return; }

    if(remain>0){
      toast(`Cooldown: wait ${(Math.ceil(remain/100)/10).toFixed(1)}s`);
      return;
    }
    setU32(pos.x,pos.y,currentColor); save();
    localStorage.setItem('rplace_last_place', String(now));
  }

  function toast(msg){
    let t = document.querySelector('.toast');
    if(!t){ t=document.createElement('div'); t.className='toast'; document.body.appendChild(t); }
    t.textContent = msg; clearTimeout(t._timer);
    t._timer = setTimeout(()=> t.remove(), 1500);
  }

  // Cooldown ticker
  setInterval(()=>{
    const now = Date.now();
    const last = Number(localStorage.getItem('rplace_last_place'))||0;
    const remain = Math.max(0, last + PLACE_COOLDOWN_MS - now);
    cooldownLabel.textContent = remain ? (remain/1000).toFixed(1)+'s' : 'ready';
  }, 100);

  // ==== Render loop ==========================================================
  const gridColor = '#00000022';
  function render(){
    // Clear
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Compute visible region in world pixels
    const x0 = Math.max(0, Math.floor(-viewX / zoom));
    const y0 = Math.max(0, Math.floor(-viewY / zoom));
    const x1 = Math.min(CANVAS_SIZE, Math.ceil((canvas.width - viewX) / zoom));
    const y1 = Math.min(CANVAS_SIZE, Math.ceil((canvas.height - viewY) / zoom));

    // Draw pixels (as rects) for visible region only for simplicity
    for(let y=y0; y<y1; y++){
      let sx = Math.floor(viewX + x0*zoom);
      const sy = Math.floor(viewY + y*zoom);
      for(let x=x0; x<x1; x++){
        const u = u32At(x,y);
        ctx.fillStyle = u32ToCss(u);
        ctx.fillRect(sx, sy, Math.ceil(zoom), Math.ceil(zoom));
        sx += Math.ceil(zoom);
      }
    }

    // Grid at high zoom
    if(showGrid && zoom>=8){
      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      ctx.beginPath();
      for(let x=x0; x<=x1; x++){
        const sx = Math.floor(viewX + x*zoom)+.5; // crisp
        ctx.moveTo(sx, Math.floor(viewY + y0*zoom));
        ctx.lineTo(sx, Math.floor(viewY + y1*zoom));
      }
      for(let y=y0; y<=y1; y++){
        const sy = Math.floor(viewY + y*zoom)+.5;
        ctx.moveTo(Math.floor(viewX + x0*zoom), sy);
        ctx.lineTo(Math.floor(viewX + x1*zoom), sy);
      }
      ctx.stroke();
    }

    requestAnimationFrame(render);
  }
  render();

  // Resize canvas to viewport
  function fit(){
    const main = document.querySelector('main');
    const rect = main.getBoundingClientRect();
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio||1));
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    canvas.style.width = rect.width + 'px';
    canvas.style.height = rect.height + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  new ResizeObserver(fit).observe(document.querySelector('main'));
  fit();

  // ===== Optional: minimal sync hooks (for real backend) =====================
  // To make this multi-user: broadcast pixel writes and apply incoming writes.
  // Example shape you can send over WebSocket/Firebase: {x,y,color:u32, ts}
  //
  // function onRemotePixel({x,y,color}){ setU32(x,y,color); save(); }
  // function sendPixel(x,y,color){ /* socket.emit('px', {x,y,color}) */ }
  // In handleClick, after setU32(...): sendPixel(pos.x,pos.y,currentColor);

  </script>

<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js';
import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js';
import {
  getDatabase, ref, get, onChildAdded, onChildChanged, update, serverTimestamp
} from 'https://www.gstatic.com/firebasejs/12.1.0/firebase-database.js';

// --- 1) Firebase config ---
const firebaseConfig = {
  apiKey: "AIzaSyCFwsKrYr_BiMUO3g35laAmBLgl3GzaFRA",
  authDomain: "qplace-7c542.firebaseapp.com",
  databaseURL: "https://qplace-7c542-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "qplace-7c542",
  storageBucket: "qplace-7c542.firebasestorage.app",
  messagingSenderId: "224424418446",
  appId: "1:224424418446:web:fa49879ead2e9609f73ddf",
  measurementId: "G-NNXQH6VTTG"
};

// --- 2) Init Firebase ---
const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getDatabase(app);

// --- 3) Anonymous login ---
await signInAnonymously(auth).catch(console.error);

// --- 4) Board path ---
const BOARD_PATH = `boards/${CANVAS_SIZE}`;
const pxRef = ref(db, `${BOARD_PATH}/px`);

// --- 5) Load existing pixels ---
get(pxRef).then(snap => {
  const all = snap.val();
  if (!all) return;
  for (const k in all) {
    const [x, y] = k.split('_').map(Number);
    const v = all[k]?.c ?? 0;
    setU32(x, y, v >>> 0);
  }
  save();
});

// --- 6) Live updates ---
onChildAdded(pxRef, s => {
  const [x, y] = s.key.split('_').map(Number);
  const v = s.val()?.c ?? 0;
  setU32(x, y, v >>> 0);
  save();
});
onChildChanged(pxRef, s => {
  const [x, y] = s.key.split('_').map(Number);
  const v = s.val()?.c ?? 0;
  setU32(x, y, v >>> 0);
  save();
});

// --- 7) Send pixel to Firebase ---
async function sendPixel(x, y, colorUint32) {
  const uid = (auth.currentUser && auth.currentUser.uid) || 'anon';
  const key = `${x}_${y}`;
  const updates = {};
  updates[`${BOARD_PATH}/px/${key}`] = { c: colorUint32 >>> 0, u: uid, ts: serverTimestamp() };
  updates[`${BOARD_PATH}/users/${uid}/last`] = serverTimestamp();
  await update(ref(db), updates);
}

// --- 8) Modify handleClick to send pixel ---
const originalHandleClick = handleClick;
handleClick = async function(e){
  const pos = screenToWorld(e);
  if(!pos) return;

  // --- Cooldown check ---
  const now = Date.now();
  const last = Number(localStorage.getItem('rplace_last_place'))||0;
  const remain = last + PLACE_COOLDOWN_MS - now;
  if(remain>0){ toast(`Cooldown: wait ${(Math.ceil(remain/100)/10).toFixed(1)}s`); return; }

  // --- Eyedropper ---
  if(eyedropper){
    currentColor = u32At(pos.x,pos.y);
    hud.textContent = `Picked ${u32ToCss(currentColor)} — click to place or press Esc/V to exit`;
    return;
  }

  // --- Draw locally ---
  setU32(pos.x,pos.y,currentColor); 
  save();
  localStorage.setItem('rplace_last_place', String(now));

  // --- Send to Firebase ---
  try { await sendPixel(pos.x,pos.y,currentColor); } catch(err){ console.warn('Firebase error', err); }
};
</script>
</body>
</html>
